{"version":3,"sources":["webpack:///./src/js/angular/resources/chart-models/chart-data.js","webpack:///./src/js/angular/resources/chart-models/cluster-health/cluster-health-chart.js"],"names":["ChartData","translateService","chart","interpolate","type","height","margin","left","right","x","d","y","clipEdge","noData","instant","showControls","duration","rightAlignYAxis","useInteractiveGuideline","xAxis","showMaxMin","tickFormat","d3","time","format","Date","yAxis","legend","maxKeyLength","color","scale","category10","range","title","enable","text","this","getTitle","subtitle","className","getSubTitle","chartOptions","subTitle","html","disableRangeUpdate","disableOldDataRemoval","getChartOptions","chartSetup","dataHolder","createDataHolder","firstLoad","Error","timestamp","newData","removeOldData","addNewData","isFirstLoad","updateRange","values","length","forEach","data","shift","multiplier","domainUpperBound","calculateMaxChartValueAndDivisions","yDomain","Math","max","filter","disabled","flatMap","getMaxValueForDataSeries","dataSeries","map","maxDataValue","Array","isArray","getMaxValueFromDataHolder","maxChartValue","round","DEFAULT_MULTIPLIER","ceil","MAXIMUM_DIVISIONS","divisions","ClusterHealthChart","super","nodesCount","clusterHealthChartOptions","stacked","tickValues","Object","assign","key","nodesStatus","nodesStats","nodesInCluster","nodesInSync","nodesSyncing","nodesOutOfSync","nodesDisconnected","push","subTitleValues","leaderElections","term","failedRecoveries","failureRecoveriesCount","failedTransactions","failedTransactionsCount","setSubTitle"],"mappings":"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","file":"44.4d7cb09cdd1413d5f879.bundle.js","sourcesContent":["export class ChartData {\n    getChartOptions(translateService) {\n        return {\n            chart: {\n                interpolate: 'monotone',\n                type: 'lineChart',\n                height: 500,\n                margin: {\n                    left: 80,\n                    right: 80\n                },\n                x: function (d) {\n                    return d[0];\n                },\n                y: function (d) {\n                    return d[1];\n                },\n                clipEdge: true,\n                noData: translateService.instant('resource.no_data'),\n                showControls: false,\n                duration: 0,\n                rightAlignYAxis: false,\n                useInteractiveGuideline: true,\n                xAxis: {\n                    showMaxMin: false,\n                    tickFormat: function (d) {\n                        return d3.time.format('%X')(new Date(d));\n                    }\n                },\n                yAxis: {\n                    showMaxMin: false,\n                    tickFormat: function (d) {\n                        return d;\n                    }\n                },\n                legend: {\n                    maxKeyLength: 100\n                },\n                color: d3.scale.category10().range()\n            },\n            title: {\n                enable: true,\n                text: this.getTitle()\n            },\n            subtitle: {\n                className: 'chart-additional-info',\n                enable: true,\n                text: this.getSubTitle()\n            }\n        };\n    }\n\n    /**\n     * Must implement\n     * @return {string} the title name\n     */\n    getTitle() {\n        return 'No chart title set';\n    }\n\n    setTitle(title) {\n        this.chartOptions.title.enable = true;\n        this.chartOptions.title.text = title;\n    }\n\n    getSubTitle() {\n    }\n\n    setSubTitle(subTitle) {\n        this.chartOptions.subtitle.enable = true;\n        this.chartOptions.subtitle.html = subTitle;\n    }\n\n    /**\n     * Defines the default multiplier for chart overhead. The space above the maximum value.\n     */\n    static get DEFAULT_MULTIPLIER() {\n        return 1.2;\n    }\n\n    /**\n     * Defines the default divisions for chart. Used to calculate chart ticks.\n     */\n    static get MAXIMUM_DIVISIONS() {\n        return 10;\n    }\n\n    constructor(translateService, chartOptions, disableRangeUpdate, disableOldDataRemoval) {\n        this.disableRangeUpdate = disableRangeUpdate;\n        this.disableOldDataRemoval = disableOldDataRemoval;\n        this.translateService = translateService;\n        this.range = 150;\n        this.chartOptions = this.getChartOptions(translateService);\n        this.chartSetup(this.chartOptions);\n        this.dataHolder = this.createDataHolder();\n        this.firstLoad = true;\n    }\n\n    /**\n     * Provides chart options if custom setup needs to be done\n     * @param chartOptions\n     */\n    chartSetup(chartOptions) {\n    }\n\n    /**\n     * Returns the data holder array for the chart data.\n     * Must be implemented.\n     */\n    createDataHolder() {\n        throw new Error('Must implement data holder creation');\n    }\n\n    /**\n     * Adds data to the data holder\n     * @param timestamp time of the data\n     * @param newData the new data\n     */\n    addData(timestamp, newData) {\n        if (!this.disableOldDataRemoval) {\n            this.removeOldData(this.dataHolder, this.range);\n        }\n        this.addNewData(this.dataHolder, timestamp, newData, this.isFirstLoad());\n        if (!this.disableRangeUpdate) {\n            this.updateRange(this.dataHolder);\n        }\n        if (this.firstLoad) {\n            this.firstLoad = false;\n        }\n    }\n\n    /**\n     * Removes data from the data holder that is obsolete based on range property\n     * @param dataHolder data holder\n     * @param range the number of entries to keep\n     */\n    removeOldData(dataHolder, range) {\n        if (dataHolder[0].values.length > range) {\n            dataHolder.forEach((data) => data.values.shift());\n        }\n    }\n\n    /**\n     * Adds data to data holder\n     * Must be implemented.\n     * @param dataHolder\n     * @param timestamp\n     * @param data\n     * @param isFirstLoad\n     */\n    addNewData(dataHolder, timestamp, data, isFirstLoad) {\n    }\n\n    /**\n     * Updates the chart axis range, based on maximum value in data holder\n     * @param dataHolder\n     * @param multiplier\n     */\n    updateRange(dataHolder, multiplier) {\n        const [domainUpperBound] = ChartData.calculateMaxChartValueAndDivisions(dataHolder, multiplier);\n        this.chartOptions.chart.yDomain = [0, domainUpperBound];\n    }\n\n    isFirstLoad() {\n        return this.firstLoad;\n    }\n\n    /**\n     * Returns the maximum value in data holder\n     * @param dataHolder\n     * @return {number}\n     */\n    static getMaxValueFromDataHolder(dataHolder) {\n        return Math.max(...dataHolder.filter((data) => !data.disabled).flatMap((data) => ChartData.getMaxValueForDataSeries(data)));\n    }\n\n    /**\n     * Returns the maximum value in specific data series\n     * @param dataSeries\n     * @return {number}\n     */\n    static getMaxValueForDataSeries(dataSeries) {\n        return Math.max(...dataSeries.values.map((data) => data[1]));\n    }\n\n    /**\n     * Calculated maximum value for chart axis and divisions width\n     * @param dataHolder\n     * @param multiplier\n     * @return {(number|number)[]}\n     */\n    static calculateMaxChartValueAndDivisions(dataHolder, multiplier) {\n        let maxDataValue;\n\n        if (Array.isArray(dataHolder)) {\n            maxDataValue = ChartData.getMaxValueFromDataHolder(dataHolder);\n        } else {\n            maxDataValue = ChartData.getMaxValueForDataSeries(dataHolder);\n        }\n\n        const maxChartValue = Math.round(maxDataValue * (multiplier || ChartData.DEFAULT_MULTIPLIER)) || 1;\n        const div = Math.ceil(maxChartValue / ChartData.MAXIMUM_DIVISIONS);\n        return [maxChartValue, div];\n    }\n\n    /**\n     * Returnes a D3 range for chart axis based on maximum value and divisions width\n     * @param dataHolder\n     * @param multiplier\n     * @return {*}\n     */\n    static getIntegerRangeForValues(dataHolder, multiplier) {\n        const [maxChartValue, divisions] = ChartData.calculateMaxChartValueAndDivisions(dataHolder, multiplier);\n        return d3.range(0, maxChartValue + 1, divisions);\n    }\n}\n","import {ChartData} from '../chart-data';\n\nexport class ClusterHealthChart extends ChartData {\n    constructor(translateService, chartOptions) {\n        super(translateService, chartOptions, true, false);\n        this.nodesCount = 0;\n    }\n    chartSetup(chartOptions) {\n        const clusterHealthChartOptions = {\n            type: 'stackedAreaChart',\n            interpolate: 'step-after',\n            stacked: true,\n            yAxis: {\n                showMaxMin: false,\n                tickFormat: function (d) {\n                    return d;\n                },\n                tickValues: () => {\n                    return d3.range(0, this.nodesCount + 1, 1);\n                }\n            }\n        };\n        Object.assign(chartOptions.chart, clusterHealthChartOptions);\n    }\n\n    getTitle() {\n        return this.translateService.instant('resources.cluster_health.label');\n    }\n\n    createDataHolder() {\n        return [{\n            key: this.translateService.instant('resources.cluster_health.in_sync'),\n            values: []\n        }, {\n            key: this.translateService.instant('resources.cluster_health.syncing'),\n            color: '#ff5508',\n            values: []\n        }, {\n            key: this.translateService.instant('resources.cluster_health.out_sync'),\n            color: '#f52121',\n            values: []\n        }, {\n            key: this.translateService.instant('resources.cluster_health.disconnected'),\n            color: '#999999',\n            values: []\n        }];\n    }\n    addNewData(dataHolder, timestamp, data) {\n        const nodesStatus = data.nodesStats;\n        this.nodesCount = nodesStatus.nodesInCluster;\n        const [nodesInSync, nodesSyncing, nodesOutOfSync, nodesDisconnected] = dataHolder;\n\n        nodesInSync.values.push([timestamp, nodesStatus.nodesInSync]);\n        nodesOutOfSync.values.push([timestamp, nodesStatus.nodesOutOfSync]);\n        nodesDisconnected.values.push([timestamp, nodesStatus.nodesDisconnected]);\n        nodesSyncing.values.push([timestamp, nodesStatus.nodesSyncing]);\n\n        const subTitleValues = {\n            leaderElections: data.term,\n            failedRecoveries: data.failureRecoveriesCount,\n            failedTransactions: data.failedTransactionsCount\n        };\n        this.setSubTitle(this.translateService.instant('resource.cluster_health.additional_data', subTitleValues));\n    }\n}\n"],"sourceRoot":""}