{"version":3,"sources":["webpack:///./src/js/angular/resources/chart-models/chart-data.js","webpack:///./src/js/angular/resources/chart-models/resource/disk-storage-chart.js"],"names":["ChartData","translateService","chart","interpolate","type","height","margin","left","right","x","d","y","clipEdge","noData","instant","showControls","duration","rightAlignYAxis","useInteractiveGuideline","xAxis","showMaxMin","tickFormat","d3","time","format","Date","yAxis","legend","maxKeyLength","color","scale","category10","range","title","enable","text","this","getTitle","subtitle","className","getSubTitle","chartOptions","subTitle","html","disableRangeUpdate","disableOldDataRemoval","getChartOptions","chartSetup","dataHolder","createDataHolder","firstLoad","Error","timestamp","newData","removeOldData","addNewData","isFirstLoad","updateRange","values","length","forEach","data","shift","multiplier","domainUpperBound","calculateMaxChartValueAndDivisions","yDomain","Math","max","filter","disabled","flatMap","getMaxValueForDataSeries","dataSeries","map","maxDataValue","Array","isArray","getMaxValueFromDataHolder","maxChartValue","round","DEFAULT_MULTIPLIER","ceil","MAXIMUM_DIVISIONS","divisions","DiskStorageChart","super","diskStorageChartOptions","stacked","toFixed","Object","assign","key","storageData","storageMemory","used","free","push","dataDirUsed","dataDirFree","workDirUsed","workDirFree","logsDirUsed","logsDirFree"],"mappings":"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","file":"49.2e7858348448fdde1332.bundle.js","sourcesContent":["export class ChartData {\n    getChartOptions(translateService) {\n        return {\n            chart: {\n                interpolate: 'monotone',\n                type: 'lineChart',\n                height: 500,\n                margin: {\n                    left: 80,\n                    right: 80\n                },\n                x: function (d) {\n                    return d[0];\n                },\n                y: function (d) {\n                    return d[1];\n                },\n                clipEdge: true,\n                noData: translateService.instant('resource.no_data'),\n                showControls: false,\n                duration: 0,\n                rightAlignYAxis: false,\n                useInteractiveGuideline: true,\n                xAxis: {\n                    showMaxMin: false,\n                    tickFormat: function (d) {\n                        return d3.time.format('%X')(new Date(d));\n                    }\n                },\n                yAxis: {\n                    showMaxMin: false,\n                    tickFormat: function (d) {\n                        return d;\n                    }\n                },\n                legend: {\n                    maxKeyLength: 100\n                },\n                color: d3.scale.category10().range()\n            },\n            title: {\n                enable: true,\n                text: this.getTitle()\n            },\n            subtitle: {\n                className: 'chart-additional-info',\n                enable: true,\n                text: this.getSubTitle()\n            }\n        };\n    }\n\n    /**\n     * Must implement\n     * @return {string} the title name\n     */\n    getTitle() {\n        return 'No chart title set';\n    }\n\n    setTitle(title) {\n        this.chartOptions.title.enable = true;\n        this.chartOptions.title.text = title;\n    }\n\n    getSubTitle() {\n    }\n\n    setSubTitle(subTitle) {\n        this.chartOptions.subtitle.enable = true;\n        this.chartOptions.subtitle.html = subTitle;\n    }\n\n    /**\n     * Defines the default multiplier for chart overhead. The space above the maximum value.\n     */\n    static get DEFAULT_MULTIPLIER() {\n        return 1.2;\n    }\n\n    /**\n     * Defines the default divisions for chart. Used to calculate chart ticks.\n     */\n    static get MAXIMUM_DIVISIONS() {\n        return 10;\n    }\n\n    constructor(translateService, chartOptions, disableRangeUpdate, disableOldDataRemoval) {\n        this.disableRangeUpdate = disableRangeUpdate;\n        this.disableOldDataRemoval = disableOldDataRemoval;\n        this.translateService = translateService;\n        this.range = 150;\n        this.chartOptions = this.getChartOptions(translateService);\n        this.chartSetup(this.chartOptions);\n        this.dataHolder = this.createDataHolder();\n        this.firstLoad = true;\n    }\n\n    /**\n     * Provides chart options if custom setup needs to be done\n     * @param chartOptions\n     */\n    chartSetup(chartOptions) {\n    }\n\n    /**\n     * Returns the data holder array for the chart data.\n     * Must be implemented.\n     */\n    createDataHolder() {\n        throw new Error('Must implement data holder creation');\n    }\n\n    /**\n     * Adds data to the data holder\n     * @param timestamp time of the data\n     * @param newData the new data\n     */\n    addData(timestamp, newData) {\n        if (!this.disableOldDataRemoval) {\n            this.removeOldData(this.dataHolder, this.range);\n        }\n        this.addNewData(this.dataHolder, timestamp, newData, this.isFirstLoad());\n        if (!this.disableRangeUpdate) {\n            this.updateRange(this.dataHolder);\n        }\n        if (this.firstLoad) {\n            this.firstLoad = false;\n        }\n    }\n\n    /**\n     * Removes data from the data holder that is obsolete based on range property\n     * @param dataHolder data holder\n     * @param range the number of entries to keep\n     */\n    removeOldData(dataHolder, range) {\n        if (dataHolder[0].values.length > range) {\n            dataHolder.forEach((data) => data.values.shift());\n        }\n    }\n\n    /**\n     * Adds data to data holder\n     * Must be implemented.\n     * @param dataHolder\n     * @param timestamp\n     * @param data\n     * @param isFirstLoad\n     */\n    addNewData(dataHolder, timestamp, data, isFirstLoad) {\n    }\n\n    /**\n     * Updates the chart axis range, based on maximum value in data holder\n     * @param dataHolder\n     * @param multiplier\n     */\n    updateRange(dataHolder, multiplier) {\n        const [domainUpperBound] = ChartData.calculateMaxChartValueAndDivisions(dataHolder, multiplier);\n        this.chartOptions.chart.yDomain = [0, domainUpperBound];\n    }\n\n    isFirstLoad() {\n        return this.firstLoad;\n    }\n\n    /**\n     * Returns the maximum value in data holder\n     * @param dataHolder\n     * @return {number}\n     */\n    static getMaxValueFromDataHolder(dataHolder) {\n        return Math.max(...dataHolder.filter((data) => !data.disabled).flatMap((data) => ChartData.getMaxValueForDataSeries(data)));\n    }\n\n    /**\n     * Returns the maximum value in specific data series\n     * @param dataSeries\n     * @return {number}\n     */\n    static getMaxValueForDataSeries(dataSeries) {\n        return Math.max(...dataSeries.values.map((data) => data[1]));\n    }\n\n    /**\n     * Calculated maximum value for chart axis and divisions width\n     * @param dataHolder\n     * @param multiplier\n     * @return {(number|number)[]}\n     */\n    static calculateMaxChartValueAndDivisions(dataHolder, multiplier) {\n        let maxDataValue;\n\n        if (Array.isArray(dataHolder)) {\n            maxDataValue = ChartData.getMaxValueFromDataHolder(dataHolder);\n        } else {\n            maxDataValue = ChartData.getMaxValueForDataSeries(dataHolder);\n        }\n\n        const maxChartValue = Math.round(maxDataValue * (multiplier || ChartData.DEFAULT_MULTIPLIER)) || 1;\n        const div = Math.ceil(maxChartValue / ChartData.MAXIMUM_DIVISIONS);\n        return [maxChartValue, div];\n    }\n\n    /**\n     * Returnes a D3 range for chart axis based on maximum value and divisions width\n     * @param dataHolder\n     * @param multiplier\n     * @return {*}\n     */\n    static getIntegerRangeForValues(dataHolder, multiplier) {\n        const [maxChartValue, divisions] = ChartData.calculateMaxChartValueAndDivisions(dataHolder, multiplier);\n        return d3.range(0, maxChartValue + 1, divisions);\n    }\n}\n","import {ChartData} from \"../chart-data\";\n\nexport class DiskStorageChart extends ChartData {\n    constructor(translateService, chartOptions) {\n        super(translateService, chartOptions, true, true);\n    }\n    chartSetup(chartOptions) {\n        const diskStorageChartOptions = {\n            type: 'multiBarHorizontalChart',\n            stacked: true,\n            showControls: false,\n            color: d3.scale.category10().range(),\n            xAxis: {\n                showMaxMin: false,\n                tickFormat: function (d) {\n                    return d;\n                }\n            },\n            yAxis: {\n                showMaxMin: false,\n                tickFormat: function (d) {\n                    return (d * 100).toFixed(2) + '%';\n                }\n            },\n            yDomain: [0, 1]\n        };\n        Object.assign(chartOptions.chart, diskStorageChartOptions);\n    }\n\n    getTitle() {\n        return this.translateService.instant('resource.storage.label');\n    }\n\n    createDataHolder() {\n        return [{\n            key: this.translateService.instant('resource.storage.used'),\n            values: []\n        }, {\n            key: this.translateService.instant('resource.storage.free'),\n            values: []\n        }];\n    }\n\n    addNewData(dataHolder, timestamp, data, isFirstLoad) {\n        const storageData = data.storageMemory;\n        const [used, free] = dataHolder;\n\n        if (isFirstLoad) {\n            used.values.push([this.translateService.instant('resource.storage.data'), 0]);\n            used.values.push([this.translateService.instant('resource.storage.work'), 0]);\n            used.values.push([this.translateService.instant('resource.storage.logs'), 0]);\n            free.values.push([this.translateService.instant('resource.storage.data'), 1]);\n            free.values.push([this.translateService.instant('resource.storage.work'), 1]);\n            free.values.push([this.translateService.instant('resource.storage.logs'), 1]);\n        }\n\n        used.values[0][1] = storageData.dataDirUsed / (storageData.dataDirUsed + storageData.dataDirFree);\n        used.values[1][1] = storageData.workDirUsed / (storageData.workDirUsed + storageData.workDirFree);\n        used.values[2][1] = storageData.logsDirUsed / (storageData.logsDirUsed + storageData.logsDirFree);\n        free.values[0][1] = storageData.dataDirFree / (storageData.dataDirUsed + storageData.dataDirFree);\n        free.values[1][1] = storageData.workDirFree / (storageData.workDirUsed + storageData.workDirFree);\n        free.values[2][1] = storageData.logsDirFree / (storageData.logsDirUsed + storageData.logsDirFree);\n    }\n}\n"],"sourceRoot":""}