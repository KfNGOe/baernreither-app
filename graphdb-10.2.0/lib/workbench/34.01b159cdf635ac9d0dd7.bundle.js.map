{"version":3,"sources":["webpack:///./src/js/angular/resources/chart-models/chart-data.js","webpack:///./src/js/angular/resources/chart-models/resource/heap-memory-chart.js","webpack:///./src/js/angular/resources/chart-models/resource/non-heap-memory-chart.js"],"names":["ChartData","translateService","chart","interpolate","type","height","margin","left","right","x","d","y","clipEdge","noData","instant","showControls","duration","rightAlignYAxis","useInteractiveGuideline","xAxis","showMaxMin","tickFormat","d3","time","format","Date","yAxis","legend","maxKeyLength","color","scale","category10","range","title","enable","text","this","getTitle","subtitle","className","getSubTitle","chartOptions","subTitle","html","disableRangeUpdate","disableOldDataRemoval","getChartOptions","chartSetup","dataHolder","createDataHolder","firstLoad","Error","timestamp","newData","removeOldData","addNewData","isFirstLoad","updateRange","values","length","forEach","data","shift","multiplier","domainUpperBound","calculateMaxChartValueAndDivisions","yDomain","Math","max","filter","disabled","flatMap","getMaxValueForDataSeries","dataSeries","map","maxDataValue","Array","isArray","getMaxValueFromDataHolder","maxChartValue","round","DEFAULT_MULTIPLIER","ceil","MAXIMUM_DIVISIONS","divisions","HeapMemoryChart","super","key","area","committed","used","memoryData","parseData","push","setMaxHeapSize","heapMemoryUsage","maxMemory","formatBytesValue","setSubTitle","setScale","value","i","floor","log","parseFloat","pow","toFixed","NonHeapMemoryChart","nonHeapMemoryUsage"],"mappings":"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","file":"34.01b159cdf635ac9d0dd7.bundle.js","sourcesContent":["export class ChartData {\n    getChartOptions(translateService) {\n        return {\n            chart: {\n                interpolate: 'monotone',\n                type: 'lineChart',\n                height: 500,\n                margin: {\n                    left: 80,\n                    right: 80\n                },\n                x: function (d) {\n                    return d[0];\n                },\n                y: function (d) {\n                    return d[1];\n                },\n                clipEdge: true,\n                noData: translateService.instant('resource.no_data'),\n                showControls: false,\n                duration: 0,\n                rightAlignYAxis: false,\n                useInteractiveGuideline: true,\n                xAxis: {\n                    showMaxMin: false,\n                    tickFormat: function (d) {\n                        return d3.time.format('%X')(new Date(d));\n                    }\n                },\n                yAxis: {\n                    showMaxMin: false,\n                    tickFormat: function (d) {\n                        return d;\n                    }\n                },\n                legend: {\n                    maxKeyLength: 100\n                },\n                color: d3.scale.category10().range()\n            },\n            title: {\n                enable: true,\n                text: this.getTitle()\n            },\n            subtitle: {\n                className: 'chart-additional-info',\n                enable: true,\n                text: this.getSubTitle()\n            }\n        };\n    }\n\n    /**\n     * Must implement\n     * @return {string} the title name\n     */\n    getTitle() {\n        return 'No chart title set';\n    }\n\n    setTitle(title) {\n        this.chartOptions.title.enable = true;\n        this.chartOptions.title.text = title;\n    }\n\n    getSubTitle() {\n    }\n\n    setSubTitle(subTitle) {\n        this.chartOptions.subtitle.enable = true;\n        this.chartOptions.subtitle.html = subTitle;\n    }\n\n    /**\n     * Defines the default multiplier for chart overhead. The space above the maximum value.\n     */\n    static get DEFAULT_MULTIPLIER() {\n        return 1.2;\n    }\n\n    /**\n     * Defines the default divisions for chart. Used to calculate chart ticks.\n     */\n    static get MAXIMUM_DIVISIONS() {\n        return 10;\n    }\n\n    constructor(translateService, chartOptions, disableRangeUpdate, disableOldDataRemoval) {\n        this.disableRangeUpdate = disableRangeUpdate;\n        this.disableOldDataRemoval = disableOldDataRemoval;\n        this.translateService = translateService;\n        this.range = 150;\n        this.chartOptions = this.getChartOptions(translateService);\n        this.chartSetup(this.chartOptions);\n        this.dataHolder = this.createDataHolder();\n        this.firstLoad = true;\n    }\n\n    /**\n     * Provides chart options if custom setup needs to be done\n     * @param chartOptions\n     */\n    chartSetup(chartOptions) {\n    }\n\n    /**\n     * Returns the data holder array for the chart data.\n     * Must be implemented.\n     */\n    createDataHolder() {\n        throw new Error('Must implement data holder creation');\n    }\n\n    /**\n     * Adds data to the data holder\n     * @param timestamp time of the data\n     * @param newData the new data\n     */\n    addData(timestamp, newData) {\n        if (!this.disableOldDataRemoval) {\n            this.removeOldData(this.dataHolder, this.range);\n        }\n        this.addNewData(this.dataHolder, timestamp, newData, this.isFirstLoad());\n        if (!this.disableRangeUpdate) {\n            this.updateRange(this.dataHolder);\n        }\n        if (this.firstLoad) {\n            this.firstLoad = false;\n        }\n    }\n\n    /**\n     * Removes data from the data holder that is obsolete based on range property\n     * @param dataHolder data holder\n     * @param range the number of entries to keep\n     */\n    removeOldData(dataHolder, range) {\n        if (dataHolder[0].values.length > range) {\n            dataHolder.forEach((data) => data.values.shift());\n        }\n    }\n\n    /**\n     * Adds data to data holder\n     * Must be implemented.\n     * @param dataHolder\n     * @param timestamp\n     * @param data\n     * @param isFirstLoad\n     */\n    addNewData(dataHolder, timestamp, data, isFirstLoad) {\n    }\n\n    /**\n     * Updates the chart axis range, based on maximum value in data holder\n     * @param dataHolder\n     * @param multiplier\n     */\n    updateRange(dataHolder, multiplier) {\n        const [domainUpperBound] = ChartData.calculateMaxChartValueAndDivisions(dataHolder, multiplier);\n        this.chartOptions.chart.yDomain = [0, domainUpperBound];\n    }\n\n    isFirstLoad() {\n        return this.firstLoad;\n    }\n\n    /**\n     * Returns the maximum value in data holder\n     * @param dataHolder\n     * @return {number}\n     */\n    static getMaxValueFromDataHolder(dataHolder) {\n        return Math.max(...dataHolder.filter((data) => !data.disabled).flatMap((data) => ChartData.getMaxValueForDataSeries(data)));\n    }\n\n    /**\n     * Returns the maximum value in specific data series\n     * @param dataSeries\n     * @return {number}\n     */\n    static getMaxValueForDataSeries(dataSeries) {\n        return Math.max(...dataSeries.values.map((data) => data[1]));\n    }\n\n    /**\n     * Calculated maximum value for chart axis and divisions width\n     * @param dataHolder\n     * @param multiplier\n     * @return {(number|number)[]}\n     */\n    static calculateMaxChartValueAndDivisions(dataHolder, multiplier) {\n        let maxDataValue;\n\n        if (Array.isArray(dataHolder)) {\n            maxDataValue = ChartData.getMaxValueFromDataHolder(dataHolder);\n        } else {\n            maxDataValue = ChartData.getMaxValueForDataSeries(dataHolder);\n        }\n\n        const maxChartValue = Math.round(maxDataValue * (multiplier || ChartData.DEFAULT_MULTIPLIER)) || 1;\n        const div = Math.ceil(maxChartValue / ChartData.MAXIMUM_DIVISIONS);\n        return [maxChartValue, div];\n    }\n\n    /**\n     * Returnes a D3 range for chart axis based on maximum value and divisions width\n     * @param dataHolder\n     * @param multiplier\n     * @return {*}\n     */\n    static getIntegerRangeForValues(dataHolder, multiplier) {\n        const [maxChartValue, divisions] = ChartData.calculateMaxChartValueAndDivisions(dataHolder, multiplier);\n        return d3.range(0, maxChartValue + 1, divisions);\n    }\n}\n","import {ChartData} from \"../chart-data\";\n\nexport class HeapMemoryChart extends ChartData {\n    constructor(translateService, chartOptions) {\n        super(translateService, chartOptions, false, false);\n    }\n\n    getTitle() {\n        return this.translateService.instant('resource.memory.heap.label');\n    }\n\n    createDataHolder() {\n        return [{\n            key: this.translateService.instant('resource.memory.committed'),\n            values: []\n        }, {\n            key: this.translateService.instant('resource.memory.used'),\n            area: 'true',\n            values: []\n        }];\n    }\n    addNewData(dataHolder, timestamp, data) {\n        const [committed, used] = dataHolder;\n        const memoryData = this.parseData(data);\n        committed.values.push([timestamp, memoryData.committed]);\n        used.values.push([timestamp, memoryData.used]);\n        this.setMaxHeapSize(memoryData.max, dataHolder);\n    }\n\n    parseData(data) {\n        return data.heapMemoryUsage;\n    }\n\n    setMaxHeapSize(max, dataHolder) {\n        if (max > 0) {\n            const maxMemory = this.formatBytesValue(max);\n            this.setSubTitle(this.translateService.instant('resource.memory.heap.max', {max: maxMemory}));\n        }\n    }\n\n    updateRange(dataHolder) {\n        this.setScale(dataHolder);\n        super.updateRange(dataHolder);\n    }\n    setScale(dataHolder) {\n        this.chartOptions.chart.yAxis.tickFormat = (d) => {\n            return this.formatBytesValue(d, dataHolder);\n        };\n    }\n    formatBytesValue(value, dataHolder) {\n        let maxChartValue = value;\n        if (dataHolder) {\n            maxChartValue = Math.max(...dataHolder.filter((data)=> !data.disabled).flatMap((data) => data.values).flatMap((data) => data[1]));\n        }\n\n        const k = 1024;\n        const i = Math.floor(Math.log(maxChartValue) / Math.log(k));\n        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n\n        const relativeValue = parseFloat(value) / Math.pow(k, i);\n        return `${relativeValue.toFixed(2)} ${sizes[i]}`;\n    }\n}\n","import {HeapMemoryChart} from \"./heap-memory-chart\";\n\nexport class NonHeapMemoryChart extends HeapMemoryChart {\n    constructor(translateService, chartOptions) {\n        super(translateService, chartOptions, false, false);\n    }\n\n    getTitle() {\n        return this.translateService.instant('resource.memory.non_heap.label');\n    }\n\n    parseData(data) {\n        return data.nonHeapMemoryUsage;\n    }\n}\n"],"sourceRoot":""}