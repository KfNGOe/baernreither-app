{"version":3,"sources":["webpack:///./src/js/angular/resources/chart-models/chart-data.js","webpack:///./src/js/angular/resources/chart-models/resource/cpu-load-chart.js"],"names":["ChartData","translateService","chart","interpolate","type","height","margin","left","right","x","d","y","clipEdge","noData","instant","showControls","duration","rightAlignYAxis","useInteractiveGuideline","xAxis","showMaxMin","tickFormat","d3","time","format","Date","yAxis","legend","maxKeyLength","color","scale","category10","range","title","enable","text","this","getTitle","subtitle","className","getSubTitle","chartOptions","subTitle","html","disableRangeUpdate","disableOldDataRemoval","getChartOptions","chartSetup","dataHolder","createDataHolder","firstLoad","Error","timestamp","newData","removeOldData","addNewData","isFirstLoad","updateRange","values","length","forEach","data","shift","multiplier","domainUpperBound","calculateMaxChartValueAndDivisions","yDomain","Math","max","filter","disabled","flatMap","getMaxValueForDataSeries","dataSeries","map","maxDataValue","Array","isArray","getMaxValueFromDataHolder","maxChartValue","round","DEFAULT_MULTIPLIER","ceil","MAXIMUM_DIVISIONS","divisions","CpuLoadChart","super","key","push","formatValue","cpuLoad","parseFloat","toFixed"],"mappings":"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","file":"48.d7b02a85dfa52084b1c4.bundle.js","sourcesContent":["export class ChartData {\n    getChartOptions(translateService) {\n        return {\n            chart: {\n                interpolate: 'monotone',\n                type: 'lineChart',\n                height: 500,\n                margin: {\n                    left: 80,\n                    right: 80\n                },\n                x: function (d) {\n                    return d[0];\n                },\n                y: function (d) {\n                    return d[1];\n                },\n                clipEdge: true,\n                noData: translateService.instant('resource.no_data'),\n                showControls: false,\n                duration: 0,\n                rightAlignYAxis: false,\n                useInteractiveGuideline: true,\n                xAxis: {\n                    showMaxMin: false,\n                    tickFormat: function (d) {\n                        return d3.time.format('%X')(new Date(d));\n                    }\n                },\n                yAxis: {\n                    showMaxMin: false,\n                    tickFormat: function (d) {\n                        return d;\n                    }\n                },\n                legend: {\n                    maxKeyLength: 100\n                },\n                color: d3.scale.category10().range()\n            },\n            title: {\n                enable: true,\n                text: this.getTitle()\n            },\n            subtitle: {\n                className: 'chart-additional-info',\n                enable: true,\n                text: this.getSubTitle()\n            }\n        };\n    }\n\n    /**\n     * Must implement\n     * @return {string} the title name\n     */\n    getTitle() {\n        return 'No chart title set';\n    }\n\n    setTitle(title) {\n        this.chartOptions.title.enable = true;\n        this.chartOptions.title.text = title;\n    }\n\n    getSubTitle() {\n    }\n\n    setSubTitle(subTitle) {\n        this.chartOptions.subtitle.enable = true;\n        this.chartOptions.subtitle.html = subTitle;\n    }\n\n    /**\n     * Defines the default multiplier for chart overhead. The space above the maximum value.\n     */\n    static get DEFAULT_MULTIPLIER() {\n        return 1.2;\n    }\n\n    /**\n     * Defines the default divisions for chart. Used to calculate chart ticks.\n     */\n    static get MAXIMUM_DIVISIONS() {\n        return 10;\n    }\n\n    constructor(translateService, chartOptions, disableRangeUpdate, disableOldDataRemoval) {\n        this.disableRangeUpdate = disableRangeUpdate;\n        this.disableOldDataRemoval = disableOldDataRemoval;\n        this.translateService = translateService;\n        this.range = 150;\n        this.chartOptions = this.getChartOptions(translateService);\n        this.chartSetup(this.chartOptions);\n        this.dataHolder = this.createDataHolder();\n        this.firstLoad = true;\n    }\n\n    /**\n     * Provides chart options if custom setup needs to be done\n     * @param chartOptions\n     */\n    chartSetup(chartOptions) {\n    }\n\n    /**\n     * Returns the data holder array for the chart data.\n     * Must be implemented.\n     */\n    createDataHolder() {\n        throw new Error('Must implement data holder creation');\n    }\n\n    /**\n     * Adds data to the data holder\n     * @param timestamp time of the data\n     * @param newData the new data\n     */\n    addData(timestamp, newData) {\n        if (!this.disableOldDataRemoval) {\n            this.removeOldData(this.dataHolder, this.range);\n        }\n        this.addNewData(this.dataHolder, timestamp, newData, this.isFirstLoad());\n        if (!this.disableRangeUpdate) {\n            this.updateRange(this.dataHolder);\n        }\n        if (this.firstLoad) {\n            this.firstLoad = false;\n        }\n    }\n\n    /**\n     * Removes data from the data holder that is obsolete based on range property\n     * @param dataHolder data holder\n     * @param range the number of entries to keep\n     */\n    removeOldData(dataHolder, range) {\n        if (dataHolder[0].values.length > range) {\n            dataHolder.forEach((data) => data.values.shift());\n        }\n    }\n\n    /**\n     * Adds data to data holder\n     * Must be implemented.\n     * @param dataHolder\n     * @param timestamp\n     * @param data\n     * @param isFirstLoad\n     */\n    addNewData(dataHolder, timestamp, data, isFirstLoad) {\n    }\n\n    /**\n     * Updates the chart axis range, based on maximum value in data holder\n     * @param dataHolder\n     * @param multiplier\n     */\n    updateRange(dataHolder, multiplier) {\n        const [domainUpperBound] = ChartData.calculateMaxChartValueAndDivisions(dataHolder, multiplier);\n        this.chartOptions.chart.yDomain = [0, domainUpperBound];\n    }\n\n    isFirstLoad() {\n        return this.firstLoad;\n    }\n\n    /**\n     * Returns the maximum value in data holder\n     * @param dataHolder\n     * @return {number}\n     */\n    static getMaxValueFromDataHolder(dataHolder) {\n        return Math.max(...dataHolder.filter((data) => !data.disabled).flatMap((data) => ChartData.getMaxValueForDataSeries(data)));\n    }\n\n    /**\n     * Returns the maximum value in specific data series\n     * @param dataSeries\n     * @return {number}\n     */\n    static getMaxValueForDataSeries(dataSeries) {\n        return Math.max(...dataSeries.values.map((data) => data[1]));\n    }\n\n    /**\n     * Calculated maximum value for chart axis and divisions width\n     * @param dataHolder\n     * @param multiplier\n     * @return {(number|number)[]}\n     */\n    static calculateMaxChartValueAndDivisions(dataHolder, multiplier) {\n        let maxDataValue;\n\n        if (Array.isArray(dataHolder)) {\n            maxDataValue = ChartData.getMaxValueFromDataHolder(dataHolder);\n        } else {\n            maxDataValue = ChartData.getMaxValueForDataSeries(dataHolder);\n        }\n\n        const maxChartValue = Math.round(maxDataValue * (multiplier || ChartData.DEFAULT_MULTIPLIER)) || 1;\n        const div = Math.ceil(maxChartValue / ChartData.MAXIMUM_DIVISIONS);\n        return [maxChartValue, div];\n    }\n\n    /**\n     * Returnes a D3 range for chart axis based on maximum value and divisions width\n     * @param dataHolder\n     * @param multiplier\n     * @return {*}\n     */\n    static getIntegerRangeForValues(dataHolder, multiplier) {\n        const [maxChartValue, divisions] = ChartData.calculateMaxChartValueAndDivisions(dataHolder, multiplier);\n        return d3.range(0, maxChartValue + 1, divisions);\n    }\n}\n","import {ChartData} from \"../chart-data\";\n\nexport class CpuLoadChart extends ChartData {\n    constructor(translateService, chartOptions) {\n        super(translateService, chartOptions, false, false);\n    }\n    chartSetup(chartOptions) {\n        chartOptions.chart.yAxis.tickFormat = function (d) {\n            return d + '%';\n        };\n    }\n\n    getTitle() {\n        return this.translateService.instant('resource.system.cpu_load.label');\n    }\n\n    createDataHolder() {\n        return [{\n            key: this.translateService.instant('resource.system.cpu_load.label'),\n            values: []\n        }];\n    }\n    addNewData(dataHolder, timestamp, data) {\n        dataHolder[0].values.push([timestamp, this.formatValue(data.cpuLoad)]);\n    }\n    formatValue(cpuLoad) {\n        return parseFloat(cpuLoad).toFixed(4);\n    }\n    updateRange(dataHolder) {\n        const maxChartValue = Math.max(...dataHolder[0].values.flatMap((data) => data[1]));\n        const domainUpperBound = maxChartValue > 50 ? 100 : maxChartValue * 2;\n        this.chartOptions.chart.yDomain = [0, domainUpperBound];\n    }\n}\n"],"sourceRoot":""}