export = BaseRepositoryClient;
/**
 * Implementation of the RDF repository operations.
 *
 * The repository will construct a list of HTTP clients for each supplied
 * repository endpoint in the configuration. These clients will be used as
 * fallback strategy.
 *
 * @abstract
 * @class
 * @author Mihail Radkov
 * @author Svilen Velikov
 */
declare class BaseRepositoryClient {
    /**
     * Checks if the request that produced the provided error can be re-attempted.
     *
     * @private
     * @param {Object} error the error to check
     * @return {boolean} <code>true</code> if it can be attempted again or
     *                    <code>false</code> otherwise
     */
    private static canRetryExecution;
    /**
     * Validates the provided repository client configuration.
     *
     * @private
     * @param {RepositoryClientConfig} repositoryClientConfig the config to check
     * @throws {Error} if the configuration is not an instance of
     * {@link RepositoryClientConfig} or there are no configured endpoints
     */
    private static validateConfig;
    /**
     * Constructs a repository client with the provided configuration.
     *
     * @param {RepositoryClientConfig} repositoryClientConfig
     */
    constructor(repositoryClientConfig: RepositoryClientConfig);
    repositoryClientConfig: RepositoryClientConfig;
    httpClient: HttpClient;
    authenticationService: AuthenticationService;
    /**
     * Initializes the parser registry with default supported parsers.
     * @private
     */
    private initParsers;
    parserRegistry: ParserRegistry;
    /**
     * Initializes a logger instance.
     * @private
     */
    private initLogger;
    logger: Logger;
    /**
     * Gets a logger instance.
     *
     * @return {Logger} the logger instance
     */
    getLogger(): Logger;
    /**
     * Initializes http clients depending on the provided endpoints.
     * @private
     */
    private initHttpClients;
    httpClients: HttpClient[];
    /**
     * Register provided parser in the internal parser registry.
     *
     * @param {ContentParser} parser implementation wrapper.
     */
    registerParser(parser: ContentParser): void;
    /**
     * Parses provided content with registered parser if there is one. Otherwise
     * returns the content untouched. If <code>contentType</code> is provided it
     * should be an instance of {@link RDFMimeType} enum and is used as a key
     * for selecting appropriate parser from the parsers registry.
     * Parsing is done synchronously!
     *
     * @protected
     * @param {string} content
     * @param {string} responseType
     * @param {Object} [parserConfig] optional parser configuration
     * @return {(string|Term|Term[])}
     */
    protected parse(content: string, responseType: string, parserConfig?: any): (string | Term | Term[]);
    /**
     * Executor for http requests. It passes the provided HTTP request builder
     * to a HTTP client for executing requests.
     *
     * If the request was unsuccessful it will be retried with another endpoint
     * HTTP client in case the request's status is one of
     * {@link RETRIABLE_STATUSES} or if the host is currently unreachable.
     *
     * If all of the endpoints are unsuccessful then the execution will fail
     * with promise rejection.
     *
     * @protected
     * @param {HttpRequestBuilder} requestBuilder the http request data to be
     * passed to a http client
     * @return {Promise<HttpResponse|Error>} a promise which resolves to response
     * wrapper or rejects with error if thrown during execution.
     */
    protected execute(requestBuilder: HttpRequestBuilder): Promise<HttpResponse | Error>;
    /**
     * Retries HTTP request execution until successful or until no more clients
     * are left if the status is allowed for retry.
     *
     * @private
     * @param {Iterable} httpClients iterable collection of http clients
     * @param {HttpRequestBuilder} requestBuilder the http request data to be
     * passed to a http client
     * @param {HttpClient} [currentHttpClient] current client is passed only if
     * the retry is invoked directly in result of some error handler which may try
     * to re-execute the request to the same server.
     * @return {Promise<HttpResponse|Error>} a promise which resolves to response
     * wrapper or rejects with error if thrown during execution.
     */
    private retryExecution;
    /**
     * Allow request config to be altered before sending.
     *
     * @private
     * @param {HttpRequestBuilder} requestBuilder
     */
    private decorateRequestConfig;
    /**
     * Creates an object from the provided HTTP response that is suitable for
     * structured logging.
     *
     * Any additional key-value entries from <code>params</code> will be assigned
     * in the created payload object.
     *
     * @protected
     * @param {HttpResponse} response the HTTP response.
     * Used to get the execution time and the base URL
     * @param {object} [params] additional parameters to be appended
     * @return {object} the constructed payload object for logging
     */
    protected getLogPayload(response: HttpResponse, params?: object): object;
    /**
     * Logged user getter.
     * @return {User} user
     */
    getLoggedUser(): User;
    /**
     * User setter
     * @param {User} user
     *
     * @return {BaseRepositoryClient}
     */
    setLoggedUser(user: User): BaseRepositoryClient;
    user: User;
}
import RepositoryClientConfig = require("../repository/repository-client-config");
import HttpClient = require("../http/http-client");
import AuthenticationService = require("../service/authentication-service");
import ParserRegistry = require("../parser/parser-registry");
import HttpResponse = require("../http/http-response");
