export = TermConverter;
/**
 * Utility class for converting strings to terms, terms to quads and
 * quads to string according to the {@link https://rdf.js.org} specification.
 *
 * @class
 * @author Mihail Radkov
 * @author Svilen Velikov
 * @author Teodossi Dossev
 */
declare class TermConverter {
    /**
     * Convert the supplied params to a collection of quads.
     *
     * The produced quads size depends on the supplied amount of context.
     *
     * @public
     * @static
     * @param {string} subject the quad's subject
     * @param {string} predicate the quad's predicate
     * @param {string} object the quad's object
     * @param {(string|string[])} [contexts] the quad's context
     * @return {Quad[]} a collection of quads constructed from the provided params
     */
    public static getQuads(subject: string, predicate: string, object: string, contexts?: (string | string[])): Quad[];
    /**
     * Convert the supplied params to a collection of quads.
     *
     * The quads object term will be a literal with a data type or a language.
     *
     * The produced quads size depends on the supplied amount of context.
     *
     * @public
     * @static
     * @param {string} subject the quad's subject
     * @param {string} predicate the quad's predicate
     * @param {string} object the quad's object
     * @param {(string|string[])} [contexts] the quad's context
     * @param {string} type the quad's data type
     * @param {string} language the quad's literal language
     * @return {Quad[]} a collection of quads constructed from the provided params
     */
    public static getLiteralQuads(subject: string, predicate: string, object: string, contexts?: (string | string[]), type: string, language: string): Quad[];
    /**
     * Convert the supplied params to terms and then to a collection of quads.
     * The supplied object should already be converted to a term.
     *
     * The produced quads size depends on the supplied amount of context.
     *
     * @private
     * @static
     * @param {string} subject the quad's subject
     * @param {string} predicate the quad's predicate
     * @param {Term} objectTerm the quads object already converted to a Term
     * @param {(string|string[])} contexts the quad's context
     * @return {Quad[]} collection of quads constructed from the provided params
     */
    private static toQuads;
    /**
     * Serializes the provided collection of quads to Turtle format or Trig in
     * case any of the quads have context.
     *
     * @public
     * @static
     * @param {Quad[]} quads the collection of quads to serialize to Turtle
     * @return {string} a promise that will be resolved to Turtle or Trig
     * text or rejected if the quads cannot be serialized
     */
    public static toString(quads: Quad[]): string;
    /**
     * Converts the provided value to N-Triple encoded value in case it is not
     * already one or a literal value.
     *
     * For example:
     * <ul>
     *   <li><i>http://resource</i> encodes to <i><http://resource></i></li>
     *   <li><i>"Literal title"@en</i> will not be encoded</li>
     *   <li><i><http://resource></i> encodes to the same value</li>
     * </ul>
     *
     * Empty or null values are ignored.
     *
     * @public
     * @static
     * @param {string} value the value for converting
     * @return {string} the converted value to N-Triple
     */
    public static toNTripleValue(value: string): string;
    /**
     * Converts the provided values to N-Triple encoded values in case they are
     * not already one or literal values.
     *
     * Empty or null values are ignored.
     *
     * @see {@link #toNTripleValue}
  
     * @public
     * @static
     * @param {string|string[]} values the values for converting
     * @return {string|string[]} the converted value or values to N-Triple
     */
    public static toNTripleValues(values: string | string[]): string | string[];
    /**
     * Converts the provided subject string to a specific Term based on the value.
     *
     * @private
     * @param {string} value the subject to convert
     * @return {BlankNode|Variable|NamedNode} the provided subject as Term
     */
    private static toSubject;
    /**
     * Converts the provided predicate string to a specific Term based on the
     * value.
     *
     * @private
     * @param {string} value the predicate to convert
     * @return {Variable|NamedNode} the provided predicate as Term
     */
    private static toPredicate;
    /**
     * Converts the provided object string to a specific Term based on the value.
     *
     * This is not handling literal strings. For that use
     * {@link TermConverter#toObjectWithLanguage} or
     * {@link TermConverter#toObjectWithDataType}
     *
     * @private
     * @param {string} value the object to convert
     * @return {BlankNode|Variable|NamedNode} the provided object as Term
     */
    private static toObject;
    /**
     * Converts the provided object and language to a Literal term.
     *
     * @private
     * @param {string} object the value to convert
     * @param {string} language the object's language
     * @return {Literal} the provided object as Literal
     */
    private static toObjectWithLanguage;
    /**
     * Converts the provided object and data type to a Literal term.
     *
     * @private
     * @param {string} object the value to convert
     * @param {string} dataType the object's type
     * @return {Literal} the provided object as Literal
     */
    private static toObjectWithDataType;
    /**
     * Converts the provided context to a collection of Term.
     *
     * The produced terms size depends on the supplied amount of context.
     *
     * @private
     * @param {string|string[]} [contexts] the contexts to convert
     * @return {Term[]} the provided contexts as Terms
     */
    private static toGraphs;
    /**
     * Converts the provided string to a specific Term based on the value.
     *
     * <ul>
     *  <li>If the string begins with <code>_:</code> it will be converted to a
     *  blank node term.</li>
     *  <li>If the string begins with <code>?</code> it will be converted to a
     *  variable term.</li>
     *  <li>Otherwise it will be converted a simple named node term.</li>
     * </ul>
     *
     * @private
     * @param {string} value the string to convert
     * @return {BlankNode|Variable|NamedNode} the provided value as Term
     */
    private static toTerm;
    /**
     * Returns a variable term from the provided value without leading ?
     *
     * @private
     * @param {string} value the value to convert to variable
     * @return {Variable} the produced variable
     */
    private static toVariable;
    /**
     * Checks if the provided value is a blank node.
     *
     * Blank nodes are such values that start with <code>_:</code> prefix
     *
     * @private
     * @param {string} value the value to check
     * @return {boolean} <code>true</code> if the value is a blank node
     *                    or <code>false</code> otherwise
     */
    private static isBlankNode;
    /**
     * Checks if the provided value is a variable.
     *
     * Variables are such values that start with <code>?</code> prefix
     *
     * @private
     * @param {string} value the value to check
     * @return {boolean} <code>true</code> if the value is a variable
     *                    or <code>false</code> otherwise
     */
    private static isVariable;
    /**
     * Instantiates new N3 writer for quads.
     *
     * This writer is not reusable, after invoking <code>end()</code> it won't
     * allow further quads insertions.
     *
     * @private
     * @return {N3.Writer} new writer for quads
     */
    private static getWriter;
    /**
     * Decodes from Base64 encoded RDFStar triple.
     *
     * @param {string} encodedTriple to be decoded from base64 url string
     * @return {string} decoded RDFStar triple, returns unchanged if the provided
     * triple is not in the expected format
     */
    static fromBase64RdfStarTriple(encodedTriple: string): string;
    /**
     * Encodes RDFStarTriple to Base64 string.
     *
     * @param {string} triple to be encoded as base64 url string
     * @return {string} encoded RDFStart triple, returns unchanged if the provided
     * triple is not in the expected format
     */
    static toBase64RdfStarTriple(triple: string): string;
}
